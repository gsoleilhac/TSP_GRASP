function eval(perm::Array{Int,1},distancier::Array{Float64,2})::Float64
	z=0.0
	for i = 1:(length(perm)-1)
		z += distancier[perm[i],perm[i+1]]
	end
	z+= distancier[perm[end],perm[1]]
	return z
end

#Cheapest Insertion Heuristic
function CIH(xyData::Array{Point,1}, distancier::Array{Float64,2}, f)::Array{Int,1}
	n = length(xyData)
	hull = convexHull(xyData)	#enveloppe convexe
	l = length(hull)
	left = setdiff(collect(1:n), hull) #indices des villes qu'il reste à ajouter
	writedlm(f, transpose(hull), " ")
	while l < n
		bestmin = left[1] #ville la plus intéressante à ajouter
		valuebestmin = distancier[hull[1],left[1]] + distancier[left[1],hull[2]] - distancier[hull[1],hull[2]]
		indexbestmin = 2 #index auquel ajouter la ville dans la solution
		for v in left
			for i = 1:length(hull)
				dist = distancier[hull[i],v] + distancier[v,hull[(i%l) + 1]] - distancier[hull[i],hull[(i%l) + 1]]
				if dist < valuebestmin
					valuebestmin = dist
					bestmin = v
					indexbestmin = i+1
				end
			end
		end
		
		if indexbestmin == l+1
			push!(hull, bestmin)
		else
			splice!(hull, indexbestmin, (bestmin, hull[indexbestmin]))
		end
		writedlm(f, transpose(hull), " ")
		deleteat!(left, findfirst(left,bestmin))
		l = l + 1
	end
	
	return hull
end

#Nearest Neighbour Heuristic
function NNH(distancier::Array{Float64,2}, f)::Array{Int,1}
	n = length(xyData)
	idep = rand(1:n)
	res = [idep]
	left = setdiff(collect(1:n), res) #indices des villes qu'il reste à ajouter
	l = 1 #length(res)
	while l < n
		bestmin = left[1] #ville la plus intéressante à ajouter
		valuebestmin = distancier[res[end],left[1]]
		for v in left
				dist = distancier[res[end],v] 
				if dist < valuebestmin
					valuebestmin = dist
					bestmin = v
				end
		end
		push!(res, bestmin)
		deleteat!(left, findfirst(left,bestmin))
		writedlm(f, transpose(res), " ")
		l = l + 1
	end
	return res
end

#3-opt local search
function ls_3opt(x::Array{Int,1}, distancier::Array{Float64,2})::Void
	bestimprovement = 0.0
	indice_rearrangement = 0
	cutting_points = (0,0,0)
	n = length(x)
	for i = 1:n-4
		for j = i+2:n-2
			for k = j+2:n
				cut = distancier[x[i],x[i+1]] + distancier[x[j],x[j+1]] + distancier[x[k],x[k%n + 1]]
				rearrangement1 = distancier[x[i],x[j]] + distancier[x[i+1],x[k]] + distancier[x[j+1],x[k%n + 1]]
				rearrangement2 = distancier[x[i],x[j+1]] + distancier[x[k],x[i+1]] + distancier[x[j],x[k%n + 1]]
				rearrangement3 = distancier[x[i],x[j+1]] + distancier[x[k],x[j]] + distancier[x[i+1],x[k%n + 1]]
				rearrangement4 = distancier[x[i],x[k]] + distancier[x[j+1],x[i+1]] + distancier[x[j],x[k%n + 1]]
				zmin = min(rearrangement1, rearrangement2, rearrangement3, rearrangement4)
				#println("i,j,k = (",i,",",j,",",k,") ", zmin - cut," | ", bestimprovement)
				if zmin - cut < bestimprovement
					bestimprovement = zmin - cut
					indice_rearrangement = indmin([rearrangement1, rearrangement2, rearrangement3, rearrangement4])
					cutting_points = (i,j,k)
				end
			end
		end
	end
	
	if bestimprovement < 0.0
		i,j,k = cutting_points
		res = x[1:i]
		if indice_rearrangement == 1
			append!(res, reverse(x[i+1:j]))
			append!(res, reverse(x[j+1:k]))
		elseif indice_rearrangement == 2
			append!(res, x[j+1:k])
			append!(res, x[i+1:j])
		elseif indice_rearrangement == 3
			append!(res, x[j+1:k])
			append!(res, reverse(x[i+1:j]))
		else
			append!(res, reverse(x[j+1:k]))
			append!(res, x[i+1:j])
		end
		if k < n
			append!(res, x[k+1:n])
		end
		copy!(x, res)
		
	end	
	return
end

#2-opt local search
function ls_2opt(x::Array{Int,1}, distancier::Array{Float64,2})::Void
	bestimprovement = 0.0
	cutting_points = (0,0)
	n = length(x)
	for i = 1:n-2
		for j = i+2:n
			cut = distancier[x[i],x[i+1]] + distancier[x[j],x[j%n+1]]
			rearrangement = distancier[x[i],x[j]] + distancier[x[i+1],x[j%n+1]]
			if rearrangement - cut < bestimprovement
				bestimprovement = rearrangement - cut
				cutting_points = (i,j)
			end
		end
	end
	
	if bestimprovement < 0.0
		i,j = cutting_points
		res = x[1:i]
		append!(res, reverse(x[i+1:j]))
		if j < n
			append!(res, x[j+1:n])
		end
		copy!(x, res)
	end
	return
end

function relink(xa, xb, distancier)

	zmin = eval(xa,distancier)
	if eval(xb,distancier) < zmin
		zmin = eval(xb,distancier)
	end

	x1 = deepcopy(xa)
	x2 = deepcopy(xb)
	res = deepcopy(x1)
	n = length(x1)

	println("x1 = ", x1)
	println("x2 = ", x2)
	
	for i=1:n-2

		if x1[i] != x2[i]
			splice!(x1, findfirst(x1, x2[i]))
			value_removed = x1[i]
			x1[i] = x2[i]
		
			#TODO trouver le meilleur placement de value_removed entre les indices i+1 : end
			valuebestmin = distancier[x1[i],value_removed] + distancier[value_removed,x1[(i%(n-1))+1]] - distancier[x1[i],x1[(i%(n-1))+1]]
			indexbestmin = i+1 #index auquel ajouter la ville dans la solution

			for j = i+1:n-1
				dist = distancier[x1[j],value_removed] + distancier[value_removed,x1[(j%(n-1))+1]] - distancier[x1[j],x1[(j%(n-1))+1]]
				if dist < valuebestmin
					valuebestmin = dist
					indexbestmin = j+1
				end
			end
			
			if indexbestmin==n
				push!(x1, value_removed)
			else
				insert!(x1, indexbestmin, value_removed)
			end
		end
		ztest = eval(x1,distancier)
		if ztest < zmin
			println(x1)
			res = deepcopy(x1)
			zmin = ztest
		end
		
	end

	println("x2 = ", x2)	
	
end
		


















